// This file is the main file run by the server using 'node app.js'
// 'nodemon app.js' just stops and recalls 'node app.js' when files have changed
// Import and setup the express module
var express = require('express');
var app = express();
var port = 3700;
// Import chatServer.js as a module
var chatServer = require('./chatServer');

// These four lines are setup for express, so are essentially magic

// Where are static files are served from
// This is currently just bundle.js which is generated by the build/browserify
// browserify lets us pretend we have modules in the browser and turns the
// separate js module files into one js file that we include in our html page
app.use(express.static(__dirname + '/public'));
// Where our templates (or html) are saved
app.set('views', __dirname + '/templates');
app.engine('html', require('ejs').renderFile);
app.set('view engine', 'ejs');
// On any incoming web request ('/') render index.jade as a html page and send it back
// req is the incoming request
// res is the response we reply with
app.get('/', function(req, res) {
  res.render('index.html');
});

// Set express to listen for web requests on our desired port
var expressApp = app.listen(port);
// Import and setup our websockets server to listen on the same port
// We could have all the following code inside our chatServer module if we
// decide that it's clearer.
var io = require('socket.io').listen(expressApp);

// When we receive a connection from a new browser, call the function we've
// defined and pass in the socket (connection) to that browser.
// Here we define all the messages we want to listen to and how to process them.
var users = [];

io.sockets.on('connection', function(socket) {
  console.log('Client connected');
  // When we receive a message labelled 'register', call our function passing
  // in the data that was sent in the message. In this case it's:
  // {username: 'myusername'}
  socket.on('register', function(data) {
    console.log('Registering ' + data.username);
    users.push(data.username);

    // Pass data and the connection to our chatServer module
    // By putting all the logic in a separate function it makes it easy to test
    // without a real websockets connection - we can pass in a fake socket in
    // our tests.
    data['users'] = users;
    chatServer.send(data, io.sockets);
    chatServer.register(data, socket);
  });

  // Call our function when we get a 'send' message. Data in this case is:
  // {username: 'myUsername', message: 'Hello'}
  socket.on('send', function(data) {
    console.log(data.username + ' sent message: ' + data.message);
    // Pass the data and the connection to all the browsers into our chatServer
    // This allows us to forward on the message to all connected clients.
    data['users'] = users;
    chatServer.send(data, io.sockets);
  });

  // Disconnect is a special event that we can hook into (like io.sockets.on('connection', ...))
  // Here we supply a function with no arguments that the websockets library
  // will call for us.
  socket.on('disconnect', function() {
    console.log(socket.username + ' disconnected');
    var index = users.indexOf(socket.username);
    if (index >= 0) {
      users.splice( index, 1 );
    }

    chatServer.send(users, io.sockets);
    // Pass the socket that was disconnected into the chatServer.
    chatServer.disconnect(socket);
  });
});
